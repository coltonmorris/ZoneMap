use wow_adt::Adt;

use base64::{engine::general_purpose, Engine as _};
use flate2::{write::DeflateEncoder, Compression};

use std::collections::BTreeMap;
use std::fs::{self, File};
use std::io::{Cursor, Write};
use std::path::{Path, PathBuf};

/// Root ADT filename parser.
/// Accepts: "<map>_<x>_<y>.adt"
/// Rejects: "<map>_<x>_<y>_obj0.adt", "_tex0.adt", "_lod.adt", etc.
fn parse_root_adt_filename(path: &Path) -> Option<(String, u32, u32)> {
    if path.extension()?.to_str()?.to_ascii_lowercase() != "adt" {
        return None;
    }
    let stem = path.file_stem()?.to_str()?.to_string(); // no ".adt"
    let parts: Vec<&str> = stem.split('_').collect();
    if parts.len() != 3 {
        // root ADT is exactly 3 parts: name_x_y
        return None;
    }
    let map = parts[0].to_string();
    let x: u32 = parts[1].parse().ok()?;
    let y: u32 = parts[2].parse().ok()?;
    Some((map, x, y))
}

fn tile_key(tile_x: u32, tile_y: u32) -> u32 {
    // stable compact key for Lua table
    tile_y * 64 + tile_x
}

/// Pack 256 u32 areaIDs into 1024 bytes LE, deflate, base64.
fn encode_tile_deflate_b64(area_ids_256: &[u32]) -> Result<String, Box<dyn std::error::Error>> {
    if area_ids_256.len() != 256 {
        return Err(format!("expected 256 area IDs, got {}", area_ids_256.len()).into());
    }

    let mut raw = Vec::with_capacity(256 * 4);
    for &v in area_ids_256 {
        raw.extend_from_slice(&v.to_le_bytes());
    }

    let mut enc = DeflateEncoder::new(Vec::new(), Compression::best());
    enc.write_all(&raw)?;
    let compressed = enc.finish()?;

    Ok(general_purpose::STANDARD.encode(compressed))
}

/// Parse a single root ADT and return 256 area IDs (16x16 chunks).
/// Pads with 0s if fewer than 256 chunks, skips if no chunks at all.
fn parse_adt_areaids(path: &Path) -> Result<Option<Vec<u32>>, Box<dyn std::error::Error>> {
    let data = fs::read(path)?;
    let adt = Adt::from_reader(Cursor::new(data))?;

    // wow_adt exposes chunk.area_id for MCNK chunks
    let mut area_ids: Vec<u32> = adt
        .mcnk_chunks
        .iter()
        .map(|chunk| chunk.area_id)
        .collect();

    let chunk_count = area_ids.len();
    
    if chunk_count == 0 {
        // Truly empty tile, skip
        return Ok(None);
    }
    
    if chunk_count != 256 {
        println!("    note: {} has {} chunks (expected 256), padding with zeros", 
                 path.file_name().unwrap_or_default().to_string_lossy(), chunk_count);
        // Pad to 256 with zeros
        area_ids.resize(256, 0);
    }

    Ok(Some(area_ids))
}

/// Per-tile grid export container
pub struct TileGridExport {
    pub continent_name: String,
    /// tileKey -> base64(deflate(raw 1024 bytes of u32 LE areaids))
    pub tiles: BTreeMap<u32, String>,
}

impl TileGridExport {
    pub fn new(continent_name: &str) -> Self {
        Self {
            continent_name: continent_name.to_string(),
            tiles: BTreeMap::new(),
        }
    }

    pub fn export_lua(&self, out_path: &Path) -> std::io::Result<()> {
        let mut f = File::create(out_path)?;

        writeln!(f, "-- Auto-generated per-tile AreaID grid for {}", self.continent_name)?;
        writeln!(f, "-- Each tile is 16x16 chunks (256 u32 AreaIDs).")?;
        writeln!(f, "-- Stored as: base64(deflate(raw_bytes)), where raw_bytes = 256 * u32 little-endian (1024 bytes).")?;
        writeln!(f, "-- Generated by zone-map Rust tool")?;
        writeln!(f)?;
        writeln!(f, "local _, addon = ...")?;
        writeln!(f)?;
        writeln!(f, "local tiles = {{")?;

        // Keep lines reasonable length
        for (k, v) in &self.tiles {
            writeln!(f, "  [{}] = [[{}]],", k, v)?;
        }

        writeln!(f, "}}")?;
        writeln!(f)?;
        writeln!(f, "addon:RegisterTileGrid(\"{}\", {{", self.continent_name)?;
        writeln!(f, "  name = \"{}\",", self.continent_name)?;
        writeln!(f, "  tileSize = 16,")?;
        writeln!(f, "  tilesPerSide = 64,")?;
        writeln!(f, "  tiles = tiles,")?;
        writeln!(f, "}})")?;
        Ok(())
    }
}

fn build_tile_export(adt_dir: &Path, continent_name: &str) -> Result<TileGridExport, Box<dyn std::error::Error>> {
    let mut export = TileGridExport::new(continent_name);

    let mut parsed = 0usize;
    let mut skipped = 0usize;
    let mut errors = 0usize;

    println!("Scanning ADT dir: {}", adt_dir.display());

    for entry in fs::read_dir(adt_dir)? {
        let entry = entry?;
        let path = entry.path();
        if !path.is_file() {
            continue;
        }

        let Some((map_name, tx, ty)) = parse_root_adt_filename(&path) else {
            skipped += 1;
            continue;
        };

        // Optional: ensure the filename map matches the continent_name loosely (case-insensitive)
        // If you want strict matching, uncomment:
        // if map_name.to_ascii_lowercase() != continent_name.to_ascii_lowercase() { continue; }

        match parse_adt_areaids(&path) {
            Ok(Some(area_ids)) => {
                let b64 = encode_tile_deflate_b64(&area_ids)?;
                let key = tile_key(tx, ty);
                export.tiles.insert(key, b64);
                parsed += 1;
                if parsed % 100 == 0 {
                    println!("  parsed {} tiles...", parsed);
                }
            }
            Ok(None) => {
                // Truly empty tile (0 chunks), skip
                println!("  SKIPPED (0 chunks): {}_{}_{}",  map_name, tx, ty);
                skipped += 1;
            }
            Err(e) => {
                eprintln!("  ERROR parsing {}: {}", path.display(), e);
                errors += 1;
            }
        }
    }

    println!(
        "Done. parsed={} skipped(non-root)={} errors={}",
        parsed, skipped, errors
    );
    println!("Export tiles: {}", export.tiles.len());

    Ok(export)
}

/// Search for an area ID in all ADT files and report matches
fn search_area_id(adt_dir: &Path, search_id: u32) -> Result<(), Box<dyn std::error::Error>> {
    println!("Searching for areaID {} in {}", search_id, adt_dir.display());
    
    let mut matches: Vec<(String, u32, u32, Vec<(u32, u32)>)> = Vec::new();
    let mut files_with_terrain = 0usize;
    let mut files_water_only = 0usize;
    let mut files_total = 0usize;
    
    for entry in fs::read_dir(adt_dir)? {
        let entry = entry?;
        let path = entry.path();
        if !path.is_file() {
            continue;
        }

        let Some((map_name, tx, ty)) = parse_root_adt_filename(&path) else {
            continue;
        };
        
        files_total += 1;

        match parse_adt_areaids(&path) {
            Ok(Some(area_ids)) => {
                files_with_terrain += 1;
                
                // Find all chunks with the target area ID
                let mut chunk_matches: Vec<(u32, u32)> = Vec::new();
                for (idx, &area_id) in area_ids.iter().enumerate() {
                    if area_id == search_id {
                        let chunk_y = (idx / 16) as u32;
                        let chunk_x = (idx % 16) as u32;
                        chunk_matches.push((chunk_x, chunk_y));
                    }
                }
                
                if !chunk_matches.is_empty() {
                    matches.push((map_name, tx, ty, chunk_matches));
                }
            }
            Ok(None) => {
                files_water_only += 1;
            }
            Err(_) => {}
        }
    }
    
    println!("\nScanned {} ADT files ({} with terrain, {} water-only)", 
             files_total, files_with_terrain, files_water_only);
    
    if matches.is_empty() {
        println!("No matches found for areaID {}", search_id);
    } else {
        println!("\nFound areaID {} in {} file(s):\n", search_id, matches.len());
        
        for (map_name, tx, ty, chunks) in &matches {
            let key = tile_key(*tx, *ty);
            let filename = format!("{}_{}_{}.adt", map_name, tx, ty);
            
            if chunks.len() <= 8 {
                let chunk_str: Vec<String> = chunks.iter()
                    .map(|(cx, cy)| format!("[{},{}]", cx, cy))
                    .collect();
                println!("  {} (tile[{},{}] key={}) - {} chunks: {}", 
                    filename, tx, ty, key, chunks.len(), chunk_str.join(", "));
            } else {
                println!("  {} (tile[{},{}] key={}) - {} chunks (all 256 = full tile)", 
                    filename, tx, ty, key, chunks.len());
            }
        }
        
        println!("\nTotal: {} chunks across {} tiles", 
            matches.iter().map(|(_, _, _, c)| c.len()).sum::<usize>(),
            matches.len());
    }
    
    Ok(())
}

/// List all unique area IDs found in ADT files
fn list_area_ids(adt_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    println!("Scanning for all area IDs in {}", adt_dir.display());
    
    let mut all_ids: std::collections::BTreeMap<u32, usize> = std::collections::BTreeMap::new();
    let mut files_scanned = 0usize;
    
    for entry in fs::read_dir(adt_dir)? {
        let entry = entry?;
        let path = entry.path();
        if !path.is_file() {
            continue;
        }

        let Some(_) = parse_root_adt_filename(&path) else {
            continue;
        };

        match parse_adt_areaids(&path) {
            Ok(Some(area_ids)) => {
                files_scanned += 1;
                for &area_id in &area_ids {
                    if area_id != 0 {
                        *all_ids.entry(area_id).or_insert(0) += 1;
                    }
                }
            }
            Ok(None) => {}
            Err(_) => {}
        }
    }
    
    println!("\nScanned {} ADT files", files_scanned);
    println!("Found {} unique area IDs:\n", all_ids.len());
    
    // Sort by count (most common first)
    let mut sorted: Vec<_> = all_ids.into_iter().collect();
    sorted.sort_by(|a, b| b.1.cmp(&a.1));
    
    for (id, count) in sorted.iter().take(50) {
        println!("  areaID {:>5} - {} chunks", id, count);
    }
    
    if sorted.len() > 50 {
        println!("  ... and {} more area IDs", sorted.len() - 50);
    }
    
    Ok(())
}

// ADT tile size constants
const ADT_TILE_SIZE: f64 = 533.33333;
const ADT_HALF_SIZE: f64 = ADT_TILE_SIZE * 32.0; // 17066.67

/// Convert tile coordinates to world coordinates
/// Returns (x, y) matching the WoW API's worldPos.x, worldPos.y format
fn tile_to_world(tile_x: u32, tile_y: u32) -> (f64, f64) {
    // WoW API worldPos: x and y are swapped relative to tile indices
    // worldPos.y corresponds to tileX, worldPos.x corresponds to tileY
    let world_pos_x = ADT_HALF_SIZE - (tile_y as f64) * ADT_TILE_SIZE;
    let world_pos_y = ADT_HALF_SIZE - (tile_x as f64) * ADT_TILE_SIZE;
    (world_pos_y, world_pos_x)
}

/// Inspect a single ADT file and print all area IDs
fn inspect_adt(adt_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    println!("Inspecting: {}\n", adt_path.display());
    
    // Check if file exists
    if !adt_path.exists() {
        println!("ERROR: File does not exist!");
        return Ok(());
    }
    
    // Parse filename for tile coords
    if let Some((map_name, tx, ty)) = parse_root_adt_filename(adt_path) {
        let key = tile_key(tx, ty);
        println!("Map: {}, Tile: [{}, {}], Key: {}\n", map_name, tx, ty, key);
        
        // Check for related files
        let parent = adt_path.parent().unwrap_or(Path::new("."));
        let obj0_path = parent.join(format!("{}_{}_{}_obj0.adt", map_name, tx, ty));
        let tex0_path = parent.join(format!("{}_{}_{}_tex0.adt", map_name, tx, ty));
        let lod_path = parent.join(format!("{}_{}_{}_lod.adt", map_name, tx, ty));
        
        println!("Related files:");
        println!("  _obj0.adt: {}", if obj0_path.exists() { "exists" } else { "not found" });
        println!("  _tex0.adt: {}", if tex0_path.exists() { "exists" } else { "not found" });
        println!("  _lod.adt:  {}", if lod_path.exists() { "exists" } else { "not found" });
        println!();
        
        // Calculate world coordinates of the 4 corners
        let (nw_x, nw_y) = tile_to_world(tx, ty);           // Northwest (top-left)
        let (ne_x, ne_y) = tile_to_world(tx + 1, ty);       // Northeast (top-right)
        let (sw_x, sw_y) = tile_to_world(tx, ty + 1);       // Southwest (bottom-left)
        let (se_x, se_y) = tile_to_world(tx + 1, ty + 1);   // Southeast (bottom-right)
        
        println!("World Coordinates (corners):");
        println!("  NW (top-left):     ({:.2}, {:.2})", nw_x, nw_y);
        println!("  NE (top-right):    ({:.2}, {:.2})", ne_x, ne_y);
        println!("  SW (bottom-left):  ({:.2}, {:.2})", sw_x, sw_y);
        println!("  SE (bottom-right): ({:.2}, {:.2})", se_x, se_y);
        println!();
    }
    
    let data = fs::read(adt_path)?;
    let file_size = data.len();
    println!("File size: {} bytes ({:.2} KB)\n", file_size, file_size as f64 / 1024.0);
    
    let adt = Adt::from_reader(Cursor::new(data))?;
    
    let area_ids: Vec<u32> = adt
        .mcnk_chunks
        .iter()
        .map(|chunk| chunk.area_id)
        .collect();
    
    println!("MCNK Chunks: {} (expected 256)", area_ids.len());
    
    // Check for water data
    let has_water = adt.mh2o.is_some();
    println!("MH2O Water data: {}", if has_water { "YES" } else { "no" });
    println!();
    
    if area_ids.is_empty() {
        println!("No MCNK terrain chunks found in this ADT file.");
        println!("\nThis could mean:");
        println!("  - Ocean/water-only tile (no land terrain)");
        println!("  - Tile uses a different format or is a stub file");
        println!("  - File may be corrupted or incomplete");
        
        // Check if file is suspiciously small
        if file_size < 1000 {
            println!("\nWARNING: File is very small ({} bytes) - likely a stub/placeholder!", file_size);
        }
        
        // Show first bytes to help identify format
        let data = fs::read(adt_path)?;
        if data.len() >= 8 {
            let magic = String::from_utf8_lossy(&data[0..4]);
            println!("\nFile header (first 4 bytes): {:?} = '{}'", &data[0..4], magic);
            
            // Scan for chunk headers (4-byte ASCII identifiers)
            println!("\nChunk headers found in file:");
            let mut pos = 0;
            let mut chunks_found = Vec::new();
            while pos + 8 <= data.len() {
                // Check if this looks like a chunk header (4 ASCII bytes)
                let potential_header = &data[pos..pos+4];
                if potential_header.iter().all(|&b| b >= 0x20 && b <= 0x7E) {
                    let header_str = String::from_utf8_lossy(potential_header).to_string();
                    // Common ADT chunk headers
                    if ["MVER", "MHDR", "MCIN", "MTEX", "MMDX", "MMID", "MWMO", "MWID", 
                        "MDDF", "MODF", "MCNK", "MH2O", "MFBO", "MTXF", "MTXP"].contains(&header_str.as_str()) {
                        if !chunks_found.contains(&header_str) {
                            chunks_found.push(header_str);
                        }
                    }
                }
                pos += 1;
            }
            if chunks_found.is_empty() {
                println!("  (none found - file may not be standard ADT format)");
            } else {
                println!("  {}", chunks_found.join(", "));
            }
        }
        
        return Ok(());
    }
    
    // Count unique area IDs
    let mut counts: std::collections::BTreeMap<u32, usize> = std::collections::BTreeMap::new();
    for &id in &area_ids {
        *counts.entry(id).or_insert(0) += 1;
    }
    
    println!("Unique area IDs ({}):", counts.len());
    for (id, count) in &counts {
        let percentage = (*count as f64 / area_ids.len() as f64) * 100.0;
        println!("  areaID {:>5} - {:>3} chunks ({:.1}%)", id, count, percentage);
    }
    
    // Print 16x16 grid visualization
    println!("\n16x16 Chunk Grid (area IDs):\n");
    
    // Header row
    print!("     ");
    for x in 0..16 {
        print!("{:>5}", x);
    }
    println!();
    print!("     ");
    for _ in 0..16 {
        print!("-----");
    }
    println!();
    
    // Grid rows
    for y in 0..16 {
        print!("{:>2} | ", y);
        for x in 0..16 {
            let idx = y * 16 + x;
            if idx < area_ids.len() {
                let id = area_ids[idx];
                if id == 0 {
                    print!("    .");
                } else {
                    print!("{:>5}", id);
                }
            } else {
                print!("    -");
            }
        }
        println!();
    }
    
    Ok(())
}

/// Dump area info for every ADT file in a directory
fn dump_all_adts(adt_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    println!("Dumping area info for all ADT files in {}\n", adt_dir.display());
    println!("{:<30} {:>8} {:>8} {:>8}  {}", "File", "Tile", "Key", "Chunks", "Area IDs (count)");
    println!("{}", "-".repeat(100));
    
    let mut entries: Vec<_> = fs::read_dir(adt_dir)?
        .filter_map(|e| e.ok())
        .filter(|e| e.path().is_file())
        .collect();
    
    // Sort by filename for consistent output
    entries.sort_by(|a, b| a.file_name().cmp(&b.file_name()));
    
    let mut files_processed = 0usize;
    let mut files_with_terrain = 0usize;
    let mut files_water_only = 0usize;
    
    for entry in entries {
        let path = entry.path();
        
        let Some((map_name, tx, ty)) = parse_root_adt_filename(&path) else {
            continue;
        };
        
        files_processed += 1;
        let key = tile_key(tx, ty);
        let filename = format!("{}_{}_{}.adt", map_name, tx, ty);
        
        match parse_adt_areaids(&path) {
            Ok(Some(area_ids)) => {
                files_with_terrain += 1;
                
                // Count unique area IDs
                let mut counts: std::collections::BTreeMap<u32, usize> = std::collections::BTreeMap::new();
                for &id in &area_ids {
                    if id != 0 {
                        *counts.entry(id).or_insert(0) += 1;
                    }
                }
                
                // Format area IDs with counts
                let area_strs: Vec<String> = counts.iter()
                    .map(|(id, count)| format!("{}({})", id, count))
                    .collect();
                
                let non_zero_chunks: usize = area_ids.iter().filter(|&&id| id != 0).count();
                
                println!("{:<30} [{:>2},{:>2}] {:>8} {:>8}  {}", 
                    filename, tx, ty, key, non_zero_chunks, area_strs.join(", "));
            }
            Ok(None) => {
                files_water_only += 1;
                println!("{:<30} [{:>2},{:>2}] {:>8} {:>8}  (water only)", 
                    filename, tx, ty, key, 0);
            }
            Err(e) => {
                println!("{:<30} [{:>2},{:>2}] {:>8}  ERROR: {}", 
                    filename, tx, ty, key, e);
            }
        }
    }
    
    println!("{}", "-".repeat(100));
    println!("\nSummary: {} files ({} with terrain, {} water-only)", 
             files_processed, files_with_terrain, files_water_only);
    
    Ok(())
}

/// Parse WDT file manually (the wow-wdt crate has compatibility issues)
fn parse_wdt_tiles(data: &[u8]) -> Option<[[bool; 64]; 64]> {
    // Find MAIN chunk (stored as reversed "NIAM")
    let main_marker = b"NIAM";
    let main_pos = data.windows(4).position(|w| w == main_marker)?;
    
    // Skip marker (4) + size (4) to get to entries
    let entries_start = main_pos + 8;
    
    // Each entry is 8 bytes: 4 bytes flags + 4 bytes area_id
    // 64x64 = 4096 entries
    let mut tiles = [[false; 64]; 64];
    
    for i in 0..4096 {
        let offset = entries_start + i * 8;
        if offset + 4 > data.len() {
            break;
        }
        
        let flags = u32::from_le_bytes([
            data[offset], data[offset + 1], data[offset + 2], data[offset + 3]
        ]);
        
        // Flag 0x01 = has ADT
        if flags & 0x01 != 0 {
            let x = i % 64;
            let y = i / 64;
            tiles[y][x] = true;
        }
    }
    
    Some(tiles)
}

/// Inspect a WDT file and print tile presence map
fn inspect_wdt(wdt_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    println!("Inspecting WDT: {}\n", wdt_path.display());
    
    if !wdt_path.exists() {
        println!("ERROR: File does not exist!");
        return Ok(());
    }
    
    let data = fs::read(wdt_path)?;
    let file_size = data.len();
    println!("File size: {} bytes ({:.2} KB)\n", file_size, file_size as f64 / 1024.0);
    
    let tiles = parse_wdt_tiles(&data).ok_or("Failed to parse WDT file")?;
    
    // Count tiles and find bounds
    let mut tile_count = 0;
    let mut min_x = 64usize;
    let mut max_x = 0usize;
    let mut min_y = 64usize;
    let mut max_y = 0usize;
    
    for y in 0..64 {
        for x in 0..64 {
            if tiles[y][x] {
                tile_count += 1;
                min_x = min_x.min(x);
                max_x = max_x.max(x);
                min_y = min_y.min(y);
                max_y = max_y.max(y);
            }
        }
    }
    
    println!("Tiles present: {} / 4096", tile_count);
    if tile_count > 0 {
        println!("Tile range: X=[{}, {}], Y=[{}, {}]", min_x, max_x, min_y, max_y);
        println!("Bounding size: {}x{} tiles\n", max_x - min_x + 1, max_y - min_y + 1);
    }
    
    // Print visual map of tile presence
    println!("Tile presence map (64x64, '█' = exists, '·' = empty):\n");
    
    // Header with X coordinates (every 10)
    print!("     ");
    for x in 0..64 {
        if x % 10 == 0 {
            print!("{:<10}", x);
        }
    }
    println!();
    
    // Grid
    for y in 0..64 {
        print!("{:>3} |", y);
        for x in 0..64 {
            if tiles[y][x] {
                print!("█");
            } else {
                print!("·");
            }
        }
        println!("|");
    }
    
    // List all present tiles
    println!("\nPresent tiles ({}):", tile_count);
    let mut tile_list: Vec<(usize, usize)> = Vec::new();
    for y in 0..64 {
        for x in 0..64 {
            if tiles[y][x] {
                tile_list.push((x, y));
            }
        }
    }
    
    // Print in columns
    let cols = 8;
    for chunk in tile_list.chunks(cols) {
        print!("  ");
        for (x, y) in chunk {
            print!("[{:>2},{:>2}] ", x, y);
        }
        println!();
    }
    
    Ok(())
}

fn print_usage(program: &str) {
    println!("ZoneMap ADT Tool\n");
    println!("Usage:");
    println!("  {} export <adt_directory> <continent_name>", program);
    println!("    Export ADT area data to Lua file for the addon");
    println!("    Example: {} export ./kalimdor_adts Kalimdor\n", program);
    
    println!("  {} search <area_id> <adt_directory>", program);
    println!("    Search for an area ID and list all ADT files containing it");
    println!("    Example: {} search 215 ./kalimdor_adts\n", program);
    
    println!("  {} list <adt_directory>", program);
    println!("    List all unique area IDs found in ADT files");
    println!("    Example: {} list ./kalimdor_adts\n", program);
    
    println!("  {} inspect <adt_file>", program);
    println!("    Inspect a single ADT file and print all area IDs");
    println!("    Example: {} inspect ./kalimdor_adts/kalimdor_36_32.adt\n", program);
    
    println!("  {} dump <adt_directory>", program);
    println!("    Dump area info for every ADT file in a directory");
    println!("    Example: {} dump ./kalimdor_adts\n", program);
    
    println!("  {} wdt <wdt_file>", program);
    println!("    Inspect a WDT file and show tile presence map");
    println!("    Example: {} wdt ./kalimdor.wdt", program);
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = std::env::args().collect();
    
    if args.len() < 2 {
        print_usage(&args[0]);
        return Ok(());
    }
    
    let command = args[1].as_str();
    
    match command {
        "export" => {
            if args.len() < 4 {
                println!("Usage: {} export <adt_directory> <continent_name>", args[0]);
                return Ok(());
            }
            let adt_dir = PathBuf::from(&args[2]);
            let continent_name = &args[3];
            
            let export = build_tile_export(&adt_dir, continent_name)?;
            let out_path = format!("{}_tiles.lua", continent_name);
            export.export_lua(Path::new(&out_path))?;
            
            println!("Wrote: {}", out_path);
        }
        
        "search" => {
            if args.len() < 4 {
                println!("Usage: {} search <area_id> <adt_directory>", args[0]);
                return Ok(());
            }
            let search_id: u32 = args[2].parse()
                .map_err(|_| format!("Invalid area ID: {}", args[2]))?;
            let adt_dir = PathBuf::from(&args[3]);
            
            search_area_id(&adt_dir, search_id)?;
        }
        
        "list" => {
            if args.len() < 3 {
                println!("Usage: {} list <adt_directory>", args[0]);
                return Ok(());
            }
            let adt_dir = PathBuf::from(&args[2]);
            
            list_area_ids(&adt_dir)?;
        }
        
        "inspect" => {
            if args.len() < 3 {
                println!("Usage: {} inspect <adt_file>", args[0]);
                return Ok(());
            }
            let adt_file = PathBuf::from(&args[2]);
            
            inspect_adt(&adt_file)?;
        }
        
        "dump" => {
            if args.len() < 3 {
                println!("Usage: {} dump <adt_directory>", args[0]);
                return Ok(());
            }
            let adt_dir = PathBuf::from(&args[2]);
            
            dump_all_adts(&adt_dir)?;
        }
        
        "wdt" => {
            if args.len() < 3 {
                println!("Usage: {} wdt <wdt_file>", args[0]);
                return Ok(());
            }
            let wdt_file = PathBuf::from(&args[2]);
            
            inspect_wdt(&wdt_file)?;
        }
        
        _ => {
            // Legacy mode: treat first arg as directory, second as continent name
            if args.len() >= 3 {
                let adt_dir = PathBuf::from(&args[1]);
                let continent_name = &args[2];
                
                let export = build_tile_export(&adt_dir, continent_name)?;
                let out_path = format!("{}_tiles.lua", continent_name);
                export.export_lua(Path::new(&out_path))?;
                
                println!("Wrote: {}", out_path);
            } else {
                print_usage(&args[0]);
            }
        }
    }
    
    Ok(())
}